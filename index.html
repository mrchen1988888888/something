<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3Dæ‰‹åŠ¿ç²’å­(æŒ‡æŒ¥å®˜ç»ˆæç‰ˆ)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-1);
        }
        
        /* çŠ¶æ€å¤§å­— */
        #mode-display {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            font-size: 20px; font-weight: bold; color: #00ff88;
            background: rgba(0,0,0,0.6); padding: 8px 24px; border-radius: 30px;
            border: 1px solid rgba(0,255,136,0.3);
            pointer-events: none; z-index: 90;
            text-align: center; white-space: nowrap;
            transition: all 0.3s;
        }
        #mode-display.locked { color: #ff3333; border-color: #ff3333; }

        /* å·¦ä¾§ä»ªè¡¨ç›˜ */
        #hud-container {
            position: absolute; top: 80px; left: 20px;
            display: flex; flex-direction: column; gap: 8px;
            pointer-events: none; z-index: 50;
        }
        .hud-item {
            background: rgba(0, 20, 40, 0.6);
            border-left: 3px solid #555;
            padding: 6px 12px; color: #aaa;
            font-family: monospace; font-size: 12px;
            border-radius: 0 5px 5px 0;
            transition: all 0.2s;
        }
        .hud-item.active {
            border-left-color: #00ff88;
            background: rgba(0, 40, 20, 0.8);
            color: #fff; transform: scale(1.05) translateX(5px);
        }

        /* åº•éƒ¨æ“ä½œé¢æ¿ */
        #ui-container { position: absolute; bottom: 0; left: 0; width: 100%; z-index: 100; pointer-events: none; }
        #ui-panel {
            pointer-events: auto; background: rgba(20, 20, 20, 0.9);
            padding: 15px; border-radius: 20px 20px 0 0; color: white;
            backdrop-filter: blur(10px);
        }

        .loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00ff88; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        .row { display: flex; gap: 10px; align-items: center; margin-top: 10px; }
        select { flex:1; padding: 10px; border-radius: 8px; border: none; background: rgba(255,255,255,0.1); color: white; }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading" class="loading-mask">
        <div class="spinner"></div>
        <div style="color:white; font-size: 14px;">åˆå§‹åŒ–æŒ‡æŒ¥å®˜ç³»ç»Ÿ...</div>
    </div>
    
    <div id="mode-display">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>

    <div id="hud-container">
        <div class="hud-item" id="h-lock">ğŸ‘Œ OK: é”å®š/è§£é”</div>
        <div class="hud-item" id="h-rot">ğŸ– å•æ‰‹: æ—‹è½¬</div>
        <div class="hud-item" id="h-zoom">ğŸ‘ åŒæ: ç¼©æ”¾</div>
        <div class="hud-item" id="h-pan">âœŠğŸ¤ æ‹³+æ: å¹³ç§»</div>
        <div class="hud-item" id="h-switch">ğŸ¤œğŸ– æ‹³+æŒ: æ¢å›¾</div>
        <div class="hud-item" id="h-view">1/2/3: åˆ‡æ¢è§†å›¾</div>
    </div>

    <div id="ui-container">
        <div id="ui-panel">
            <h2 style="margin:0; font-size:14px; opacity:0.7">æŒ‡æŒ¥å®˜æ§åˆ¶å°</h2>
            <div class="row">
                <select id="shape-select">
                    <option value="christmas">ğŸ„ åœ£è¯æ ‘</option>
                    <option value="heart">ğŸ’– çˆ±å¿ƒ</option>
                    <option value="saturn">ğŸª åœŸæ˜Ÿ</option>
                    <option value="buddha">ğŸ§˜ æ‰“å</option>
                    <option value="fireworks">ğŸ† çƒŸèŠ±</option>
                </select>
                <input type="color" id="color-picker" value="#2f9e44" style="height:35px; width:40px; border:none; background:transparent;">
            </div>
        </div>
    </div>

    <!-- åº“æ–‡ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. Three.js ---
        const PARTICLE_COUNT = 4000; // é™ä½ç²’å­æ•°é˜²æ­¢æµè§ˆå™¨å´©æºƒ
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // ç›®æ ‡ç›¸æœºä½ç½®ï¼ˆç”¨äºè§†å›¾åˆ‡æ¢ï¼‰
        let targetCamPos = { x: 0, y: 0, z: 25 };
        camera.position.set(0, 0, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT*3; i++) { positions[i] = (Math.random()-0.5)*100; targetPositions[i]=positions[i]; }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x2f9e44, size: 0.3, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- å½¢çŠ¶æ•°æ® ---
        const Shapes = {
            christmas: () => {
                const arr = []; for (let i=0; i<PARTICLE_COUNT; i++) {
                    const p=Math.random(); let x,y,z;
                    if(p>0.9){const r=Math.random()*2,t=Math.random()*6.28,f=Math.random()*3.14;x=r*Math.sin(f)*Math.cos(t);y=r*Math.sin(f)*Math.sin(t)+13;z=r*Math.cos(f);}
                    else{const h=Math.random()*22-9,maxR=9*(1-(h+9)/22),r=Math.random()*maxR,a=(h+9)*2.5+Math.random()*6.28;x=r*Math.cos(a);z=r*Math.sin(a);y=h;}
                    arr.push(x,y,z);
                } material.color.setHex(0x2f9e44); return arr;
            },
            heart: () => {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let t=Math.random()*6.28, x=16*Math.pow(Math.sin(t),3), y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
                    arr.push(x*0.5,y*0.5,(Math.random()-0.5)*5);
                } material.color.setHex(0xff0055); return arr;
            },
            saturn: () => {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let x,y,z; if(Math.random()>0.4){let r=7,t=Math.random()*6.28,f=Math.acos(2*Math.random()-1);x=r*Math.sin(f)*Math.cos(t);y=r*Math.sin(f)*Math.sin(t);z=r*Math.cos(f);}
                    else{let a=Math.random()*6.28,d=10+Math.random()*6;x=Math.cos(a)*d;y=Math.sin(a)*d;z=(Math.random()-0.5)*0.5;let ty=y;y=ty*Math.cos(0.5)-z*Math.sin(0.5);z=ty*Math.sin(0.5)+z*Math.cos(0.5);}
                    arr.push(x,y,z);
                } material.color.setHex(0xffaa55); return arr;
            },
            buddha: () => {
                 const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let p=Math.random(),t=Math.random()*6.28,f=Math.acos(2*Math.random()-1),r,x,y,z;
                    if(p<0.25){r=2.5;y=r*Math.sin(f)*Math.sin(t)+6;}else if(p<0.65){r=4.5;y=r*Math.sin(f)*Math.sin(t);}else{r=6;f=Math.random()*3.14;y=r*Math.sin(f)*Math.sin(t)*0.5-4;}
                    x=r*Math.sin(f)*Math.cos(t);z=r*Math.cos(f);
                    arr.push(x,y,z);
                } material.color.setHex(0xffaa00); return arr;
            },
            fireworks: () => {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let r=Math.pow(Math.random(),0.5)*15,t=Math.random()*6.28,f=Math.acos(2*Math.random()-1);
                    arr.push(r*Math.sin(f)*Math.cos(t),r*Math.sin(f)*Math.sin(t),r*Math.cos(f));
                } material.color.setHex(0x00ffff); return arr;
            }
        };

        const shapeKeys = Object.keys(Shapes);
        let currentShapeIndex = 0;
        
        function updateShape(key) {
            if(!Shapes[key]) return;
            const newPos = Shapes[key]();
            const posAttr = particles.geometry.attributes.position.array;
            for(let i=0; i < targetPositions.length; i++) {
                targetPositions[i] = newPos[i];
                // çˆ†ç‚¸æ•ˆæœ
                posAttr[i] = (Math.random()-0.5)*150;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            document.getElementById('shape-select').value = key;
        }
        updateShape('christmas');

        // --- æ ¸å¿ƒçŠ¶æ€ ---
        const State = {
            scale: 1.0,
            rotY: 0,
            panX: 0,
            panY: 0,
            locked: false
        };
        const RenderState = { ...State }; // ç”¨äºæ¸²æŸ“æ’å€¼

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            
            // çŠ¶æ€æ’å€¼ (å¹³æ»‘åŠ¨ç”»)
            RenderState.scale += (State.scale - RenderState.scale) * 0.1;
            RenderState.rotY += (State.rotY - RenderState.rotY) * 0.1;
            RenderState.panX += (State.panX - RenderState.panX) * 0.1;
            RenderState.panY += (State.panY - RenderState.panY) * 0.1;
            
            // ç›¸æœºä½ç½®å¹³æ»‘ç§»åŠ¨
            camera.position.x += (targetCamPos.x - camera.position.x) * 0.05;
            camera.position.y += (targetCamPos.y - camera.position.y) * 0.05;
            camera.position.z += (targetCamPos.z - camera.position.z) * 0.05;
            camera.lookAt(0,0,0);

            // ç²’å­æ›´æ–°
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let tx = targetPositions[idx] * RenderState.scale;
                let ty = targetPositions[idx+1] * RenderState.scale;
                let tz = targetPositions[idx+2] * RenderState.scale;

                // æ—‹è½¬
                const cos = Math.cos(RenderState.rotY);
                const sin = Math.sin(RenderState.rotY);
                const rx = tx * cos - tz * sin;
                const rz = tx * sin + tz * cos;
                tx = rx; tz = rz;

                pos[idx] += (tx - pos[idx]) * 0.1;
                pos[idx+1] += (ty - pos[idx+1]) * 0.1;
                pos[idx+2] += (tz - pos[idx+2]) * 0.1;
            }
            
            particles.position.x = RenderState.panX;
            particles.position.y = RenderState.panY;
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // ------------------------------------------------------------------
        // ğŸš€ å…¨èƒ½æŒ‡æŒ¥å®˜é€»è¾‘ (Commander Logic)
        // ------------------------------------------------------------------
        
        const videoElement = document.getElementById('input-video');
        const modeDisplay = document.getElementById('mode-display');
        const hudItems = {
            lock: document.getElementById('h-lock'),
            rot: document.getElementById('h-rot'),
            zoom: document.getElementById('h-zoom'),
            pan: document.getElementById('h-pan'),
            switch: document.getElementById('h-switch'),
            view: document.getElementById('h-view')
        };

        function activateHud(key) {
            Object.values(hudItems).forEach(el => el.classList.remove('active'));
            if(hudItems[key]) hudItems[key].classList.add('active');
        }

        // è¾…åŠ©çŠ¶æ€å˜é‡
        let lastOkTime = 0;
        let lastSwitchTime = 0;
        let lastPinchTime = 0;
        let prevPinchDist = 0;
        let prevRotX = 0;
        let panStart = { x: 0, y: 0, objX: 0, objY: 0 };
        let isZooming = false;
        let isPanning = false;

        const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        // --- æ‰‹åŠ¿è¯†åˆ«å‡½æ•° ---
        function isPinching(lm) {
            const d = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
            const s = Math.hypot(lm[0].x-lm[9].x, lm[0].y-lm[9].y);
            return (d/s) < 0.25;
        }
        function isFist(lm) {
            // ç®€åŒ–åˆ¤æ–­ï¼šæŒ‡å°–æ¯”æŒ‡æ ¹ä½ (yæ›´å¤§)
            return lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y && lm[20].y > lm[18].y;
        }
        function isOpen(lm) {
            return !isPinching(lm) && !isFist(lm);
        }
        function isOK(lm) {
            // æ‹‡æŒ‡é£ŸæŒ‡æåˆï¼Œå…¶ä»–ä¸‰æŒ‡ç«–ç›´
            const pinch = isPinching(lm);
            const othersUp = lm[12].y < lm[10].y && lm[16].y < lm[14].y && lm[20].y < lm[18].y;
            return pinch && othersUp;
        }
        function countFingers(lm) {
            let n = 0;
            // åˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ (æŒ‡å°–åœ¨æŒ‡æ ¹ä¸Šæ–¹)
            if(lm[8].y < lm[6].y) n++;
            if(lm[12].y < lm[10].y) n++;
            if(lm[16].y < lm[14].y) n++;
            if(lm[20].y < lm[18].y) n++;
            return n;
        }

        hands.onResults((results) => {
            document.getElementById('loading').style.display = 'none';
            const now = Date.now();
            
            const detected = results.multiHandLandmarks;
            const handedness = results.multiHandedness;
            
            if (!detected || detected.length === 0) {
                modeDisplay.innerText = "ç­‰å¾…æŒ‡ä»¤...";
                activateHud('');
                isZooming = false; isPanning = false; prevRotX = 0;
                return;
            }

            // æ•´ç†å·¦å³æ‰‹
            let leftHand = null, rightHand = null;
            for(let i=0; i<detected.length; i++) {
                if(handedness[i].label === 'Left') leftHand = detected[i];
                else rightHand = detected[i];
            }

            // ============================
            // 1. å…¨å±€é”å®š (OKæ‰‹åŠ¿) - æœ€é«˜ä¼˜å…ˆçº§
            // ============================
            let okDetected = false;
            detected.forEach(lm => { if(isOK(lm)) okDetected = true; });

            if (okDetected && (now - lastOkTime > 1500)) {
                State.locked = !State.locked;
                lastOkTime = now;
                modeDisplay.classList.toggle('locked', State.locked);
            }
            if (State.locked) {
                modeDisplay.innerText = "â›”ï¸ ç³»ç»Ÿé”å®š (OKæ‰‹åŠ¿è§£é”)";
                activateHud('lock');
                return; 
            }

            // ============================
            // 2. åŒæ‰‹æ“ä½œ (Zoom / Pan / Switch)
            // ============================
            if (leftHand && rightHand) {
                const lPinch = isPinching(leftHand);
                const rPinch = isPinching(rightHand);
                const lFist = isFist(leftHand);
                const rFist = isFist(rightHand);
                const lOpen = isOpen(leftHand);
                const rOpen = isOpen(rightHand);

                // --- åœºæ™¯åˆ‡æ¢ (æ‹³ + æŒ) ---
                if (now - lastSwitchTime > 800) {
                    if (lFist && rOpen) {
                        currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
                        updateShape(shapeKeys[currentShapeIndex]);
                        modeDisplay.innerText = "â© ä¸‹ä¸€å¼ ";
                        activateHud('switch');
                        lastSwitchTime = now;
                        return;
                    }
                    if (rFist && lOpen) {
                        currentShapeIndex = (currentShapeIndex - 1 + shapeKeys.length) % shapeKeys.length;
                        updateShape(shapeKeys[currentShapeIndex]);
                        modeDisplay.innerText = "âª ä¸Šä¸€å¼ ";
                        activateHud('switch');
                        lastSwitchTime = now;
                        return;
                    }
                }

                // --- ç¼©æ”¾ (åŒæ) ---
                if (lPinch && rPinch) {
                    const dist = Math.hypot(leftHand[9].x - rightHand[9].x, leftHand[9].y - rightHand[9].y);
                    if (!isZooming) {
                        isZooming = true;
                        prevPinchDist = dist;
                    } else {
                        const delta = (dist - prevPinchDist) * 3;
                        State.scale = Math.max(0.2, Math.min(State.scale + delta, 5.0));
                        prevPinchDist = dist;
                        modeDisplay.innerText = `ğŸ” ç¼©æ”¾: ${Math.round(State.scale*100)}%`;
                        activateHud('zoom');
                    }
                    return;
                } else { isZooming = false; }

                // --- å¹³ç§» (å•æ + å•æ‹³) ---
                if ((lPinch && rFist) || (rPinch && lFist)) {
                    const cx = (leftHand[9].x + rightHand[9].x) / 2;
                    const cy = (leftHand[9].y + rightHand[9].y) / 2;
                    
                    if (!isPanning) {
                        isPanning = true;
                        panStart = { x: cx, y: cy, ox: State.panX, oy: State.panY };
                    } else {
                        const dx = (cx - panStart.x) * -60; // çµæ•åº¦
                        const dy = (cy - panStart.y) * -60;
                        State.panX = panStart.ox + dx;
                        State.panY = panStart.oy + dy;
                        modeDisplay.innerText = "â†”ï¸ å¹³ç§»æ¨¡å¼";
                        activateHud('pan');
                    }
                    return;
                } else { isPanning = false; }
            }

            // ============================
            // 3. å•æ‰‹æ“ä½œ (Rotate / View)
            // ============================
            if (detected.length === 1) {
                const hand = detected[0];
                const pinch = isPinching(hand);
                const open = isOpen(hand);
                const fingers = countFingers(hand);

                // --- æ—‹è½¬ (å•æ‰‹å¼ å¼€) ---
                if (open) {
                    const cx = hand[9].x;
                    if (prevRotX === 0) prevRotX = cx;
                    const dx = cx - prevRotX;
                    if (Math.abs(dx) > 0.002) {
                        State.rotY += dx * 5;
                        modeDisplay.innerText = "ğŸ”„ æ—‹è½¬æ¨¡å¼";
                        activateHud('rot');
                    }
                    prevRotX = cx;
                } else {
                    prevRotX = 0;
                }

                // --- è§†å›¾åˆ‡æ¢ (1/2/3æŒ‡) ---
                if (!pinch && !isFist(hand)) {
                    if (fingers === 1) {
                        targetCamPos = { x: 0, y: 0, z: 25 };
                        modeDisplay.innerText = "ğŸ“º æ­£è§†å›¾";
                        activateHud('view');
                    } else if (fingers === 2) {
                        targetCamPos = { x: 30, y: 0, z: 0 };
                        modeDisplay.innerText = "ğŸ“º ä¾§è§†å›¾";
                        activateHud('view');
                    } else if (fingers === 3) {
                        targetCamPos = { x: 0, y: 30, z: 1 };
                        modeDisplay.innerText = "ğŸ“º ä¿¯è§†å›¾";
                        activateHud('view');
                    }
                }

                // --- åŒæå¤ä½ (å•æ‰‹å¿«é€ŸåŒå‡») ---
                if (pinch) {
                    if (now - lastPinchTime < 300 && now - lastPinchTime > 50) {
                        State.scale = 1.0; State.rotY = 0; State.panX = 0; State.panY = 0;
                        targetCamPos = { x: 0, y: 0, z: 25 };
                        modeDisplay.innerText = "âš¡ï¸ å¤ä½";
                        modeDisplay.style.color = "yellow";
                        setTimeout(() => modeDisplay.style.color = "#00ff88", 500);
                    }
                    lastPinchTime = now;
                }
            }
        });

        // å¯åŠ¨
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 480, height: 360, facingMode: 'user'
        });
        cameraUtils.start();

        // UI äº‹ä»¶
        document.getElementById('shape-select').addEventListener('change', (e) => { currentShapeIndex = Object.keys(Shapes).indexOf(e.target.value); updateShape(e.target.value); });
        document.getElementById('color-picker').addEventListener('input', (e) => material.color.set(e.target.value));
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    </script>
</body>
</html>