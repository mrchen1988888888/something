<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>双手御法传送门</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input-video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-1); /* 镜像翻转 */
        }
        
        /* HUD 界面 */
        #hud {
            position: absolute; bottom: 50px; width: 100%; text-align: center; 
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; align-items: center; gap: 8px;
        }
        .title {
            color: #f5a623; font-size: 26px; font-weight: 800; letter-spacing: 3px;
            text-shadow: 0 0 15px rgba(245, 166, 35, 0.8); margin: 0;
        }
        .status-pill {
            color: #eee; background: rgba(20, 20, 20, 0.8); 
            padding: 8px 20px; border-radius: 30px; font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s; display: flex; align-items: center; gap: 8px;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: #555; transition: background 0.3s; }
        
        /* 加载层 */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid #333; 
            border-top: 3px solid #f5a623; border-radius: 50%; 
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    
    <div id="loading">
        <div class="spinner"></div>
        <div style="color:#f5a623; font-weight:bold;">正在建立双子链接...</div>
        <div style="color:#666; font-size:12px; margin-top:5px;">国内线路加速中</div>
    </div>

    <div id="hud">
        <div class="title">ELDRITCH MAGIC</div>
        <div class="status-pill">
            <div class="dot" id="status-dot"></div>
            <span id="status-text">请举起双手</span>
        </div>
    </div>

    <!-- 国内镜像源 (速度快，无需VPN) -->
    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://npm.elemecdn.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. Three.js 视觉系统 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // 火花纹理
        const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
        const ctx = cvs.getContext('2d');
        const grd = ctx.createRadialGradient(32,32,0, 32,32,32);
        grd.addColorStop(0, '#fff'); grd.addColorStop(0.3, '#ff9900'); grd.addColorStop(1, 'transparent');
        ctx.fillStyle = grd; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cvs);

        // 粒子环
        const COUNT = 3000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(COUNT * 3);
        const data = new Float32Array(COUNT * 3); // x:speed, y:angle, z:radiusOffset
        
        for(let i=0; i<COUNT; i++) {
            pos[i*3] = 999; 
            data[i*3] = 2 + Math.random() * 4;       // 速度
            data[i*3+1] = Math.random() * Math.PI * 2; // 角度
            data[i*3+2] = (Math.random() - 0.5) * 1.5; // 半径抖动
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        
        const mat = new THREE.PointsMaterial({
            size: 0.4, map: tex, transparent: true, 
            blending: THREE.AdditiveBlending, depthWrite: false, color: 0xffaa00
        });
        const portal = new THREE.Points(geo, mat);
        scene.add(portal);

        // 内部虚空
        const voidMesh = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1, 2),
            new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0 })
        );
        scene.add(voidMesh);

        // --- 2. 状态管理 ---
        let State = {
            targetRadius: 0,
            currentRadius: 0,
            hasHands: false
        };

        function animate() {
            requestAnimationFrame(animate);

            // 缓动动画：平滑改变半径
            // 如果没检测到手，目标半径自动归零
            if (!State.hasHands) State.targetRadius = 0;
            
            State.currentRadius += (State.targetRadius - State.currentRadius) * 0.1;

            // 视觉更新
            const r = State.currentRadius;
            portal.rotation.z -= 0.05;
            
            voidMesh.scale.setScalar(r * 0.9);
            voidMesh.material.opacity = Math.min(1, r / 3);
            voidMesh.rotation.y += 0.01;

            const p = portal.geometry.attributes.position.array;
            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                data[idx+1] += data[idx] * 0.01; // 更新角度
                
                const angle = data[idx+1];
                const radius = r + data[idx+2];

                if (r > 0.1) {
                    // 极坐标 -> 笛卡尔坐标 + 随机噪点(火花飞溅)
                    const jitter = (Math.random()-0.5) * 0.2;
                    p[idx] = Math.cos(angle) * radius + jitter;
                    p[idx+1] = Math.sin(angle) * radius + jitter;
                    p[idx+2] = (Math.random()-0.5) * 0.5;
                } else {
                    p[idx] = 999; // 隐藏
                }
            }
            portal.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 3. MediaPipe 手势识别 (双手中控) ---
        const videoElement = document.getElementById('input-video');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const loadingDiv = document.getElementById('loading');

        // 使用国内源加载
        const hands = new Hands({locateFile: (file) => `https://npm.elemecdn.com/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 2, // 关键：检测两只手
            modelComplexity: 0, // Lite模型，保证流畅
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        let isLoaded = false;

        hands.onResults(results => {
            if (!isLoaded) {
                isLoaded = true;
                loadingDiv.style.display = 'none';
            }

            const detectedHands = results.multiHandLandmarks.length;

            if (detectedHands === 2) {
                State.hasHands = true;
                
                // 获取两只手的位置
                const hand1 = results.multiHandLandmarks[0];
                const hand2 = results.multiHandLandmarks[1];

                // 使用手掌中心 (点9: 中指根部) 计算距离，比手腕更稳定
                const x1 = hand1[9].x;
                const y1 = hand1[9].y;
                const x2 = hand2[9].x;
                const y2 = hand2[9].y;

                // 计算欧几里得距离 (0.0 ~ 1.0)
                const distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));

                // 映射距离到传送门半径
                // 距离 0.1 (手碰手) -> 半径 0
                // 距离 0.6 (张开双臂) -> 半径 7
                let target = (distance - 0.1) * 12; 
                target = Math.max(0, Math.min(target, 7)); // 限制范围

                State.targetRadius = target;

                // UI 反馈
                statusText.innerText = "能量连接：稳定";
                statusDot.style.background = "#00ff88";
                statusDot.style.boxShadow = "0 0 10px #00ff88";

            } else if (detectedHands === 1) {
                State.hasHands = false;
                statusText.innerText = "需双手以开启";
                statusDot.style.background = "#f5a623";
                statusDot.style.boxShadow = "none";
            } else {
                State.hasHands = false;
                statusText.innerText = "未检测到手部";
                statusDot.style.background = "#555";
                statusDot.style.boxShadow = "none";
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 640, height: 480, facingMode: 'user'
        });
        cameraUtils.start().catch(e => {
            alert("摄像头启动失败，请检查权限。");
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
