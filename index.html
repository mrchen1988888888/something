<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 粒子交互系统 - 奇异博士版</title>
    <style>
        /* --- CSS: UI & Layout --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* 隐藏原始视频流，我们只看3D */
        #input-video { display: none; }

        /* 悬浮控制面板 */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            width: 220px;
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            color: white;
            transition: transform 0.3s ease;
        }

        .panel-header { font-size: 16px; font-weight: bold; margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px; }
        
        .control-group { margin-bottom: 15px; }
        .control-label { font-size: 12px; color: #aaa; display: block; margin-bottom: 5px; }
        
        /* 颜色选择器美化 */
        input[type="color"] {
            width: 100%; height: 35px; border: none; cursor: pointer; background: none;
        }

        /* 状态显示 */
        #status-display {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            color: #00ffcc;
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }

        button {
            width: 100%; padding: 10px; background: #ea580c; border: none;
            color: white; border-radius: 6px; cursor: pointer; font-weight: bold;
            transition: background 0.2s;
        }
        button:hover { background: #c2410c; }

        /* 加载指示器 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            color: white;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #ea580c; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;}
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div>正在初始化魔法引擎 (MediaPipe)...</div>
        <div style="font-size: 12px; color: #888; margin-top: 10px;">请允许摄像头权限</div>
    </div>

    <!-- UI Panel -->
    <div id="ui-panel">
        <div class="panel-header">控制台</div>
        
        <div class="control-group">
            <span class="control-label">粒子颜色</span>
            <input type="color" id="color-picker" value="#00ffff">
        </div>

        <div class="control-group">
            <span class="control-label">实时状态</span>
            <div id="status-display">等待手势...</div>
        </div>

        <button id="fullscreen-btn">切换全屏</button>
    </div>

    <!-- WebGL Canvas -->
    <div id="canvas-container"></div>
    
    <!-- Hidden Video Element for Input -->
    <video id="input-video" playsinline></video>

    <!-- Import Libraries -->
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        /**
         * ------------------------------------------------------------------
         * 模块一：全局状态管理 (State Management)
         * ------------------------------------------------------------------
         */
        const AppState = {
            handState: 'IDLE', // IDLE, OPEN, CLOSED, MAGIC
            particleColor: new THREE.Color(0x00ffff),
            targetSpeed: 0.005,
            targetRadius: 1.0,
            magicActive: false
        };

        const DOM = {
            status: document.getElementById('status-display'),
            colorPicker: document.getElementById('color-picker'),
            loader: document.getElementById('loader')
        };

        /**
         * ------------------------------------------------------------------
         * 模块二：3D 粒子系统 (Three.js System)
         * ------------------------------------------------------------------
         */
        class World {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.02);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 5;

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 移动端性能优化
                this.container.appendChild(this.renderer.domElement);

                this.clock = new THREE.Clock();
                
                // 初始化组件
                this.initParticles();
                this.initMagicCircle();
                this.addLights();
                
                // 绑定事件
                window.addEventListener('resize', this.onResize.bind(this));
            }

            initParticles() {
                const particleCount = window.innerWidth < 800 ? 1500 : 3000; // 移动端减少粒子
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const originalPos = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i++) {
                    const val = (Math.random() - 0.5) * 10;
                    positions[i] = val;
                    originalPos[i] = val;
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.userData = { originalPos: originalPos };

                const material = new THREE.PointsMaterial({
                    size: 0.08,
                    color: AppState.particleColor,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                this.particles = new THREE.Points(this.geometry, material);
                this.scene.add(this.particles);
            }

            // 模拟奇异博士魔法阵（使用几何线条代替复杂纹理，便于单文件运行）
            initMagicCircle() {
                this.magicGroup = new THREE.Group();
                this.magicGroup.visible = false;

                // 环 1: 外部圆环
                const r1Geo = new THREE.RingGeometry(1.8, 1.9, 64);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
                const r1 = new THREE.Mesh(r1Geo, mat);
                this.magicGroup.add(r1);

                // 环 2: 内部旋转正方形
                const sGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(2.5, 2.5, 0.1));
                const sMat = new THREE.LineBasicMaterial({ color: 0xffaa00 });
                this.square = new THREE.LineSegments(sGeo, sMat);
                this.magicGroup.add(this.square);

                // 环 3: 内部文字符文模拟 (粒子环)
                const runeGeo = new THREE.BufferGeometry();
                const runePos = [];
                for(let i=0; i<100; i++) {
                    const theta = (i/100) * Math.PI * 2;
                    runePos.push(Math.cos(theta) * 1.5, Math.sin(theta) * 1.5, 0);
                }
                runeGeo.setAttribute('position', new THREE.Float32BufferAttribute(runePos, 3));
                this.runes = new THREE.Points(runeGeo, new THREE.PointsMaterial({color: 0xff4400, size: 0.1}));
                this.magicGroup.add(this.runes);

                this.scene.add(this.magicGroup);
            }

            addLights() {
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
            }

            updateColor(hex) {
                AppState.particleColor.set(hex);
                this.particles.material.color = AppState.particleColor;
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                const time = this.clock.getElapsedTime();
                const delta = this.clock.getDelta();

                // 1. 粒子动画逻辑
                this.particles.rotation.y += AppState.targetSpeed;
                
                // 获取BufferAttribute进行顶点操作
                const positions = this.particles.geometry.attributes.position.array;
                const originals = this.particles.geometry.userData.originalPos;
                const count = positions.length / 3;

                // 动态呼吸效果：根据手势调整扩散程度 (Radius)
                const targetScale = AppState.targetRadius;

                // 简单的插值动画，让粒子移动看起来平滑
                // 注意：为了性能，这里只做简单的缩放，不做复杂的逐粒子物理运算
                const currentScale = this.particles.scale.x;
                const lerpFactor = 0.05; // 平滑度
                const newScale = currentScale + (targetScale - currentScale) * lerpFactor;
                
                this.particles.scale.set(newScale, newScale, newScale);

                // 2. 魔法阵逻辑
                if (AppState.magicActive) {
                    this.magicGroup.visible = true;
                    this.magicGroup.rotation.z -= 0.02; // 整体旋转
                    this.square.rotation.z += 0.05;     // 内部正方形反向快转
                    this.runes.rotation.z -= 0.01;
                    
                    // 脉冲缩放
                    const pulse = 1 + Math.sin(time * 5) * 0.05;
                    this.magicGroup.scale.set(pulse, pulse, pulse);
                } else {
                    this.magicGroup.visible = false;
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        /**
         * ------------------------------------------------------------------
         * 模块三：手势识别 (Gesture Recognition with MediaPipe)
         * ------------------------------------------------------------------
         */
        class VisionController {
            constructor(world) {
                this.world = world;
                this.video = document.getElementById('input-video');
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });

                this.hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1, // 0 for Lite (fast), 1 for Full
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.hands.onResults(this.onResults.bind(this));

                // 启动摄像头
                this.startCamera();
            }

            async startCamera() {
                try {
                    const camera = new Camera(this.video, {
                        onFrame: async () => {
                            await this.hands.send({image: this.video});
                        },
                        width: 640, // 降低分辨率以提高移动端性能
                        height: 480
                    });
                    await camera.start();
                    DOM.loader.style.display = 'none'; // 隐藏加载层
                } catch (e) {
                    console.error(e);
                    alert("无法访问摄像头，请检查权限或HTTPS设置");
                }
            }

            onResults(results) {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    AppState.handState = 'IDLE';
                    this.updateWorldState();
                    return;
                }

                const landmarks = results.multiHandLandmarks;

                // 判定：双手合十 (如果有两只手)
                if (landmarks.length === 2) {
                    const hand1 = landmarks[0][0]; // Wrist
                    const hand2 = landmarks[1][0]; // Wrist
                    const dist = this.getDistance(hand1, hand2);
                    
                    // 这里的坐标是归一化的(0-1)，距离很小说明手腕靠在一起
                    if (dist < 0.15) {
                        AppState.handState = 'MAGIC';
                        this.updateWorldState();
                        return;
                    }
                }

                // 判定：单手张合 (取第一只手)
                const lm = landmarks[0];
                if (this.isHandOpen(lm)) {
                    AppState.handState = 'OPEN';
                } else {
                    AppState.handState = 'CLOSED';
                }
                
                this.updateWorldState();
            }

            // 计算欧几里得距离
            getDistance(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }

            // 判断手掌开合逻辑
            isHandOpen(landmarks) {
                // 简单逻辑：计算指尖(8,12,16,20)到手腕(0)的平均距离
                // 如果距离较大，则是张开；如果很小，则是握拳
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20]; // 食指、中指、无名指、小指尖
                let avgDist = 0;
                
                tips.forEach(idx => {
                    avgDist += this.getDistance(wrist, landmarks[idx]);
                });
                avgDist /= 4;

                // 阈值需要调试，归一化坐标下通常 0.2-0.3 是分界线
                return avgDist > 0.35; 
            }

            updateWorldState() {
                const s = AppState.handState;
                let statusText = "未检测到手部";

                // 重置魔法阵
                AppState.magicActive = false;

                switch(s) {
                    case 'IDLE':
                        AppState.targetRadius = 1.0;
                        AppState.targetSpeed = 0.005;
                        statusText = "等待手势...";
                        break;
                    case 'OPEN':
                        // 张开：扩散 + 慢速
                        AppState.targetRadius = 2.0; 
                        AppState.targetSpeed = 0.002;
                        statusText = "状态：扩散 (张开)";
                        break;
                    case 'CLOSED':
                        // 握拳：收缩 + 快速
                        AppState.targetRadius = 0.5;
                        AppState.targetSpeed = 0.05;
                        statusText = "状态：聚能 (握拳)";
                        break;
                    case 'MAGIC':
                        // 魔法：显示魔法阵
                        AppState.magicActive = true;
                        AppState.targetRadius = 1.5;
                        AppState.targetSpeed = 0.01;
                        statusText = "✨ 魔法阵激活 ✨";
                        break;
                }

                DOM.status.textContent = statusText;
            }
        }

        /**
         * ------------------------------------------------------------------
         * 模块四：UI 控制 (UI Controller)
         * ------------------------------------------------------------------
         */
        function initUI(world) {
            // 颜色选择器
            DOM.colorPicker.addEventListener('input', (e) => {
                world.updateColor(e.target.value);
            });

            // 全屏切换
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            });
        }

        /**
         * ------------------------------------------------------------------
         * 主入口 (Main)
         * ------------------------------------------------------------------
         */
        window.onload = () => {
            const world = new World();
            world.animate();
            
            initUI(world);

            // 初始化视觉识别（会请求摄像头）
            const vision = new VisionController(world);
        };

    </script>
</body>
</html>
