<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥‡å¼‚åšå£«ç²’å­ç³»ç»Ÿ - Three.js & MediaPipe</title>
    <style>
        :root {
            --primary-color: #ffaa00;
            --glass-bg: rgba(20, 20, 20, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; color: white; }
        canvas { display: block; }

        /* UI ä¾§è¾¹æ  */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 280px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transition: transform 0.3s ease;
            z-index: 100;
        }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; border-bottom: 1px solid var(--glass-border); padding-bottom: 10px; color: var(--primary-color); }

        .control-group { margin-bottom: 15px; }
        .label { display: block; margin-bottom: 5px; font-size: 0.9rem; color: #ccc; }
        
        /* çŠ¶æ€æ˜¾ç¤º */
        #status-box {
            background: rgba(0,0,0,0.5);
            padding: 10px; border-radius: 8px;
            font-family: monospace; font-size: 0.85rem;
            min-height: 60px;
            border-left: 3px solid var(--primary-color);
        }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type="color"] {
            width: 100%; height: 40px; border: none; cursor: pointer;
            background: transparent;
        }

        /* æŒ‰é’® */
        .btn {
            width: 100%; padding: 10px; border: none; border-radius: 8px;
            background: linear-gradient(45deg, #ff6b6b, #ffaa00);
            color: white; font-weight: bold; cursor: pointer;
            transition: opacity 0.2s;
        }
        .btn:hover { opacity: 0.9; }

        /* æ‘„åƒå¤´é¢„è§ˆ (éšè—ï¼Œç”¨äºè°ƒè¯•å¯æ˜¾ç¤º) */
        #video-input {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border-radius: 8px; opacity: 0.5;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            pointer-events: none;
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333;
            border-top: 5px solid var(--primary-color);
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- åŠ è½½å±‚ -->
    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 20px;">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹ä¸ç²’å­å¼•æ“...</p>
    </div>

    <!-- æ‘„åƒå¤´æº -->
    <video id="video-input" playsinline></video>

    <!-- UI é¢æ¿ -->
    <div id="ui-panel">
        <h2>ğŸ”® ç²’å­æ§åˆ¶å°</h2>
        
        <div class="control-group">
            <span class="label">å½“å‰çŠ¶æ€</span>
            <div id="status-box">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>
        </div>

        <div class="control-group">
            <span class="label">ç²’å­é¢œè‰²</span>
            <input type="color" id="color-picker" value="#ffaa00">
        </div>

        <button id="fullscreen-btn" class="btn">åˆ‡æ¢å…¨å±æ¨¡å¼</button>
        
        <div style="margin-top: 15px; font-size: 0.8rem; color: #888;">
            æ“ä½œæŒ‡å—:<br>
            âœ‹ å•æ‰‹å¼ å¼€: æ‰©æ•£<br>
            âœŠ å•æ‰‹æ¡æ‹³: èšèƒ½<br>
            ğŸ™Œ åŒæ‰‹åˆå: å¼€å¯ä¼ é€é—¨
        </div>
    </div>

    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        /**
         * æ¨¡å—ä¸€ï¼šç²’å­ç³»ç»Ÿå¼•æ“ (ParticleEngine)
         * è´Ÿè´£ Three.js åœºæ™¯æ¸²æŸ“ã€ç²’å­å‡ ä½•ä½“ç”Ÿæˆã€åŠ¨ç”»é€»è¾‘
         */
        class ParticleEngine {
            constructor() {
                this.container = document.body;
                this.particleCount = 15000;
                this.particles = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.material = null;
                
                // åŠ¨ç”»çŠ¶æ€
                this.baseSpeed = 0.002;
                this.targetSpeed = 0.002;
                this.expansion = 1.0; // 1 = æ­£å¸¸, 0.2 = æ”¶ç¼©, 3.0 = æ‰©æ•£
                this.targetExpansion = 1.0;
                this.isMagicMode = false; // æ˜¯å¦å¼€å¯é­”æ³•é˜µæ¨¡å¼
                
                this.init();
            }

            init() {
                // 1. åœºæ™¯è®¾ç½®
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.001);

                // 2. ç›¸æœº
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 50;

                // 3. æ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);

                // 4. ç”Ÿæˆç²’å­çº¹ç† (ç¨‹åºåŒ–ç”Ÿæˆå‘å…‰ç‚¹)
                const texture = this.createSparkTexture();

                // 5. å‡ ä½•ä½“
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const randoms = []; // ç”¨äºåŠ¨ç”»çš„éšæœºå› å­
                const colors = [];

                const colorObj = new THREE.Color("#ffaa00");

                for (let i = 0; i < this.particleCount; i++) {
                    // åˆå§‹åˆ†å¸ƒï¼šçƒå½¢äº‘
                    const r = 40 * Math.cbrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);

                    positions.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );

                    randoms.push(Math.random(), Math.random(), Math.random());
                    colors.push(colorObj.r, colorObj.g, colorObj.b);
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                // ä¿å­˜åˆå§‹ä½ç½®ç”¨äºè®¡ç®—
                this.initialPositions = Float32Array.from(positions);

                // 6. æè´¨
                this.material = new THREE.PointsMaterial({
                    size: 0.8,
                    map: texture,
                    transparent: true,
                    opacity: 0.8,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.particles = new THREE.Points(geometry, this.material);
                this.scene.add(this.particles);

                // 7. çª—å£è°ƒæ•´
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            createSparkTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 32, 32);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            }

            setColor(hex) {
                const color = new THREE.Color(hex);
                const colors = this.particles.geometry.attributes.color.array;
                for (let i = 0; i < colors.length; i += 3) {
                    colors[i] = color.r;
                    colors[i+1] = color.g;
                    colors[i+2] = color.b;
                }
                this.particles.geometry.attributes.color.needsUpdate = true;
            }

            // æ›´æ–°åŠ¨ç”»çŠ¶æ€
            updateState(state) {
                // state: { gesture: 'OPEN' | 'CLOSED' | 'DOUBLE', handPresence: boolean }
                
                if (!state.handPresence) {
                    this.targetExpansion = 1.0;
                    this.targetSpeed = 0.002;
                    this.isMagicMode = false;
                    return;
                }

                if (state.gesture === 'DOUBLE') {
                    // é­”æ³•é˜µæ¨¡å¼
                    this.isMagicMode = true;
                    this.targetSpeed = 0.05; 
                } else if (state.gesture === 'CLOSED') {
                    // æ¡æ‹³ï¼šèšèƒ½
                    this.isMagicMode = false;
                    this.targetExpansion = 0.1; // æåº¦æ”¶ç¼©
                    this.targetSpeed = 0.02; // å¿«é€Ÿæ—‹è½¬
                } else if (state.gesture === 'OPEN') {
                    // å¼ å¼€ï¼šé‡Šæ”¾
                    this.isMagicMode = false;
                    this.targetExpansion = 2.5; // æ‰©æ•£
                    this.targetSpeed = 0.001; // æ…¢é€Ÿ
                } else {
                    this.isMagicMode = false;
                    this.targetExpansion = 1.0;
                    this.targetSpeed = 0.002;
                }
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                // å¹³æ»‘æ’å€¼ (Lerp)
                this.expansion += (this.targetExpansion - this.expansion) * 0.05;
                this.baseSpeed += (this.targetSpeed - this.baseSpeed) * 0.05;

                const positions = this.particles.geometry.attributes.position.array;
                const randoms = this.particles.geometry.attributes.aRandom.array;
                
                // æ•´ä½“æ—‹è½¬
                this.particles.rotation.y -= this.baseSpeed;
                if (this.isMagicMode) this.particles.rotation.z += this.baseSpeed * 0.5;
                else this.particles.rotation.z *= 0.95; // å½’ä½

                const time = Date.now() * 0.001;

                for (let i = 0; i < this.particleCount; i++) {
                    const idx = i * 3;
                    const ox = this.initialPositions[idx];
                    const oy = this.initialPositions[idx+1];
                    const oz = this.initialPositions[idx+2];

                    let tx, ty, tz;

                    if (this.isMagicMode) {
                        // é­”æ³•é˜µé€»è¾‘ï¼šå½¢æˆå¤šä¸ªç¯
                        // åˆ©ç”¨ randoms[idx] åˆ†å±‚
                        const layer = Math.floor(randoms[idx] * 3) + 1; // 1, 2, 3å±‚
                        const angle = Math.atan2(oy, ox) + time * layer; // åŠ¨æ€æ—‹è½¬
                        const radius = 15 * layer + Math.sin(time * 5 + layer) * 2;
                        
                        tx = Math.cos(angle) * radius;
                        ty = Math.sin(angle) * radius;
                        tz = (randoms[idx+1] - 0.5) * 5; // æ‰å¹³åŒ– Z è½´
                    } else {
                        // æ™®é€šäº‘é›¾é€»è¾‘ + å‘¼å¸
                        const pulse = Math.sin(time + randoms[idx] * 10) * 0.5 + 1;
                        tx = ox * this.expansion * pulse;
                        ty = oy * this.expansion * pulse;
                        tz = oz * this.expansion * pulse;
                    }

                    // ç²’å­ä½ç½®æ›´æ–°æ’å€¼
                    positions[idx] += (tx - positions[idx]) * 0.08;
                    positions[idx+1] += (ty - positions[idx+1]) * 0.08;
                    positions[idx+2] += (tz - positions[idx+2]) * 0.08;
                }

                this.particles.geometry.attributes.position.needsUpdate = true;
                this.renderer.render(this.scene, this.camera);
            }
        }

        /**
         * æ¨¡å—äºŒï¼šæ‰‹åŠ¿è¯†åˆ« (GestureRecognizer)
         * é›†æˆ MediaPipe Handsï¼Œå¤„ç†æ‘„åƒå¤´è¾“å…¥ä¸æ‰‹åŠ¿é€»è¾‘åˆ†æ
         */
        class GestureRecognizer {
            constructor(onStateChange) {
                this.videoElement = document.getElementById('video-input');
                this.onStateChange = onStateChange;
                this.hands = null;
                this.camera = null;
                this.isReady = false;
                
                this.init();
            }

            init() {
                this.hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                this.hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.hands.onResults(this.onResults.bind(this));

                this.camera = new Camera(this.videoElement, {
                    onFrame: async () => {
                        await this.hands.send({image: this.videoElement});
                    },
                    width: 640,
                    height: 480
                });

                this.camera.start()
                    .then(() => {
                        console.log('Camera started');
                    })
                    .catch(err => {
                        console.error('Camera error:', err);
                        alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿å…è®¸æƒé™å¹¶ä½¿ç”¨HTTPSç¯å¢ƒ');
                    });
            }

            // åˆ¤æ–­å•æ‰‹æ˜¯å¼ å¼€è¿˜æ˜¯æ¡æ‹³
            isHandOpen(landmarks) {
                // ç®€å•ç®—æ³•ï¼šæ¯”è¾ƒæŒ‡å°–å’ŒæŒ‡æ ¹åˆ°æ‰‹è…•çš„è·ç¦»
                // 0: WRIST
                // æŒ‡å°–: 8, 12, 16, 20
                // æŒ‡æ ¹: 5, 9, 13, 17
                const wrist = landmarks[0];
                let extendedFingers = 0;
                
                const fingerIndices = [8, 12, 16, 20];
                const baseIndices = [5, 9, 13, 17];

                for (let i = 0; i < 4; i++) {
                    const tip = landmarks[fingerIndices[i]];
                    const base = landmarks[baseIndices[i]];
                    
                    const tipDist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                    const baseDist = Math.hypot(base.x - wrist.x, base.y - wrist.y);

                    if (tipDist > baseDist * 1.2) { // 1.2 ä¸ºå®¹å·®ç³»æ•°
                        extendedFingers++;
                    }
                }
                
                return extendedFingers >= 3; // 3æ ¹ä»¥ä¸Šç®—å¼ å¼€
            }

            onResults(results) {
                // éšè— Loading
                if (!this.isReady) {
                    document.getElementById('loader').style.display = 'none';
                    this.isReady = true;
                }

                let newState = {
                    gesture: 'IDLE',
                    text: 'ç­‰å¾…æ‰‹åŠ¿...',
                    handPresence: false
                };

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    newState.handPresence = true;
                    const numHands = results.multiHandLandmarks.length;

                    if (numHands === 2) {
                        // åŒæ‰‹æ¨¡å¼ -> é­”æ³•é˜µ
                        newState.gesture = 'DOUBLE';
                        newState.text = 'âœ¨ é­”æ³•é˜µæ¿€æ´»ï¼';
                    } else {
                        // å•æ‰‹æ¨¡å¼
                        const isOpen = this.isHandOpen(results.multiHandLandmarks[0]);
                        if (isOpen) {
                            newState.gesture = 'OPEN';
                            newState.text = 'âœ‹ æ‰‹æŒå¼ å¼€ - æ‰©æ•£';
                        } else {
                            newState.gesture = 'CLOSED';
                            newState.text = 'âœŠ æ¡æ‹³çŠ¶æ€ - èšèƒ½';
                        }
                    }
                }

                this.onStateChange(newState);
            }
        }

        /**
         * æ¨¡å—ä¸‰ï¼šUI ç®¡ç†å™¨ (UIManager)
         * å¤„ç† DOM äº‹ä»¶å’ŒçŠ¶æ€å±•ç¤º
         */
        class UIManager {
            constructor(particleEngine) {
                this.engine = particleEngine;
                this.statusBox = document.getElementById('status-box');
                this.colorPicker = document.getElementById('color-picker');
                this.fullscreenBtn = document.getElementById('fullscreen-btn');
                
                this.bindEvents();
            }

            bindEvents() {
                // é¢œè‰²æ”¹å˜
                this.colorPicker.addEventListener('input', (e) => {
                    this.engine.setColor(e.target.value);
                });

                // å…¨å±åˆ‡æ¢
                this.fullscreenBtn.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                        this.fullscreenBtn.innerText = "é€€å‡ºå…¨å±";
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                            this.fullscreenBtn.innerText = "åˆ‡æ¢å…¨å±æ¨¡å¼";
                        }
                    }
                });
            }

            updateStatus(text) {
                this.statusBox.innerText = text;
                
                // ç®€å•çš„è§†è§‰åé¦ˆ
                if (text.includes('é­”æ³•é˜µ')) {
                    this.statusBox.style.borderLeftColor = '#00ffcc';
                    this.statusBox.style.color = '#00ffcc';
                } else if (text.includes('æ¡æ‹³')) {
                    this.statusBox.style.borderLeftColor = '#ff4444';
                    this.statusBox.style.color = '#ffaaaa';
                } else {
                    this.statusBox.style.borderLeftColor = '#ffaa00';
                    this.statusBox.style.color = 'white';
                }
            }
        }

        // --- ä¸»ç¨‹åºå…¥å£ ---
        window.onload = () => {
            // 1. åˆå§‹åŒ–ç²’å­å¼•æ“
            const engine = new ParticleEngine();
            engine.animate();

            // 2. åˆå§‹åŒ–UI
            const ui = new UIManager(engine);

            // 3. åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«å¹¶è¿æ¥é€»è¾‘
            const recognizer = new GestureRecognizer((state) => {
                // æ›´æ–° UI æ–‡å­—
                ui.updateStatus(state.text);
                // æ›´æ–°ç²’å­åŠ¨ç”»é€»è¾‘
                engine.updateState(state);
            });
        };

    </script>
</body>
</html>
