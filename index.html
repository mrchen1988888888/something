<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Particle System</title>
    <style>
        /* --- æ•´ä½“é£æ ¼ä¸ CSS --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050a05; /* æ·±æ²‰çš„å¢¨ç»¿è‰²èƒŒæ™¯ */
            font-family: 'Times New Roman', serif; /* é«˜çº§æ„Ÿçš„è¡¬çº¿å­—ä½“ */
            color: #FFD700; /* é‡‘è‰²æ–‡å­— */
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* æ‘„åƒå¤´ç”»é¢ï¼ˆéšè—æˆ–åšæˆå°çª—ï¼‰ */
        #video-input {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #FFD700;
            border-radius: 8px;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            opacity: 0.7;
            z-index: 10;
            display: none; /* é»˜è®¤éšè—ï¼ŒåŠ è½½å¥½åæ˜¾ç¤º */
        }

        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        h1 {
            font-size: 2rem;
            margin: 0;
            text-shadow: 0 0 10px #FFD700;
            letter-spacing: 2px;
        }

        .status-box {
            margin-top: 10px;
            font-size: 1rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-left: 3px solid #b22222; /* åœ£è¯çº¢ */
            backdrop-filter: blur(5px);
        }

        .guide {
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 5px;
        }

        /* ä¸Šä¼ æŒ‰é’®ç¾åŒ– */
        #upload-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 20;
            pointer-events: auto;
        }

        .custom-file-upload {
            border: 1px solid #FFD700;
            display: inline-block;
            padding: 10px 20px;
            cursor: pointer;
            background: rgba(47, 90, 47, 0.8); /* å“‘å…‰ç»¿ */
            color: #FFD700;
            border-radius: 4px;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .custom-file-upload:hover {
            background: #b22222;
            color: #fff;
        }

        input[type="file"] {
            display: none;
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
            color: #FFD700;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-top: 3px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <!-- å¼•å…¥åº“ -->
    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <!-- Post Processing -->
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js" type="module"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js" type="module"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js" type="module"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js" type="module"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/shaders/LuminosityHighPassShader.js" type="module"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/jsm/shaders/CopyShader.js" type="module"></script>
    
    <!-- GSAP for Animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ... è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <div id="ui-layer">
        <h1>XMAS GESTURE ART</h1>
        <div class="status-box">
            å½“å‰çŠ¶æ€: <span id="state-text" style="color:#FFD700; font-weight:bold;">åˆæ‹¢æ€ (Tree)</span><br>
            æ£€æµ‹æ‰‹åŠ¿: <span id="gesture-text">ç­‰å¾…æ‰‹åŠ¿...</span>
        </div>
        <div class="guide">
            ğŸ– å¼ å¼€äº”æŒ‡: æ•£å¼€ | âœŠ æ¡æ‹³: èšåˆ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡ | ğŸ‘‹ æ—‹è½¬: æ•£å¼€æ—¶ç§»åŠ¨æ‰‹
        </div>
    </div>

    <div id="upload-container">
        <label class="custom-file-upload">
            <input type="file" id="photo-upload" multiple accept="image/*" />
            ğŸ“· ä¸Šä¼ ç…§ç‰‡ (ç”Ÿæˆç…§ç‰‡äº‘)
        </label>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½®å˜é‡ ---
        const CONFIG = {
            colors: {
                green: 0x2F5A2F, // å“‘å…‰ç»¿
                gold: 0xFFD700,  // é‡‘å±é‡‘
                red: 0xB22222,   // åœ£è¯çº¢
                bg: 0x050a05
            },
            particleCount: 200, // ç²’å­æ€»æ•°
            treeHeight: 30,
            treeRadius: 10,
            scatterRadius: 40,
        };

        let currentState = 'TREE'; // 'TREE', 'SCATTER', 'ZOOM'
        let previousState = 'TREE';
        let targetRotationX = 0;
        let targetRotationY = 0;
        let selectedPhotoIndex = -1;

        // --- Three.js åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- å…‰ç…§ç³»ç»Ÿ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(CONFIG.colors.gold, 1.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(CONFIG.colors.red, 2, 50);
        pointLight.position.set(0, 15, 0);
        scene.add(pointLight);

        // --- åå¤„ç† (Bloom è¾‰å…‰) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ç²’å­/ç‰©ä½“ç³»ç»Ÿ ---
        const objects = []; // å­˜å‚¨æ‰€æœ‰ Mesh
        const geometryTypes = ['sphere', 'box', 'cane', 'photo'];
        
        // æè´¨ç¼“å­˜
        const materials = {
            green: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, roughness: 0.8, metalness: 0.1 
            }),
            gold: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, roughness: 0.2, metalness: 1.0, emissive: 0x222200 
            }),
            red: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, roughness: 0.4, metalness: 0.3 
            }),
            // åˆå§‹ç…§ç‰‡æè´¨ (å ä½)
            photo: new THREE.MeshBasicMaterial({ 
                color: 0xffffff, side: THREE.DoubleSide 
            })
        };

        const textureLoader = new THREE.TextureLoader();
        let userPhotos = []; // å­˜å‚¨ä¸Šä¼ çš„çº¹ç†

        // ç”Ÿæˆç²’å­
        function initParticles() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let type = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];
                let mesh;
                
                // ç¡®ä¿è‡³å°‘æœ‰ä¸€äº›ç…§ç‰‡
                if (i < 10) type = 'photo';

                if (type === 'sphere') {
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), materials.gold);
                } else if (type === 'box') {
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), materials.red);
                } else if (type === 'cane') {
                    // ç®€åŒ–çš„ç³–æœæ£ (ç»†é•¿åœ†æŸ±)
                    mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2, 8), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    // ç»™ç³–æœæ£åŠ ä¸ªç®€å•çš„æ¡çº¹è´´å›¾æˆ–è€…åªæ˜¯ç™½è‰²ï¼Œè¿™é‡Œç®€å•å¤„ç†
                } else {
                    // Photo
                    mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2.5), materials.photo.clone());
                    mesh.userData.isPhoto = true;
                }

                // è®¡ç®—å½¢æ€åæ ‡
                // 1. åœ£è¯æ ‘å½¢æ€ (åœ†é”¥èºæ—‹)
                const percent = i / CONFIG.particleCount;
                const angle = i * 0.4 + Math.PI * 2; // èºæ—‹å› å­
                const yTree = (percent * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
                const rTree = (1 - percent) * CONFIG.treeRadius + 0.5; // åº•éƒ¨å®½é¡¶éƒ¨çª„
                const xTree = Math.cos(angle) * rTree;
                const zTree = Math.sin(angle) * rTree;

                // 2. æ•£å¼€å½¢æ€ (çƒå½¢éšæœºåˆ†å¸ƒ)
                const phi = Math.acos(-1 + (2 * i) / CONFIG.particleCount);
                const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                const rScatter = CONFIG.scatterRadius * (0.5 + Math.random() * 0.5);
                const xScatter = rScatter * Math.cos(theta) * Math.sin(phi);
                const yScatter = rScatter * Math.sin(theta) * Math.sin(phi);
                const zScatter = rScatter * Math.cos(phi);

                // æ•°æ®å­˜å‚¨
                mesh.userData = {
                    ...mesh.userData,
                    posTree: new THREE.Vector3(xTree, yTree, zTree),
                    posScatter: new THREE.Vector3(xScatter, yScatter, zScatter),
                    rotTree: new THREE.Euler(0, -angle, 0),
                    rotScatter: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                    baseScale: mesh.scale.clone()
                };

                // åˆå§‹ä½ç½®ï¼šåˆæ‹¢æ€
                mesh.position.copy(mesh.userData.posTree);
                mesh.rotation.copy(mesh.userData.rotTree);

                scene.add(mesh);
                objects.push(mesh);
            }
        }

        initParticles();

        // --- ç…§ç‰‡ä¸Šä¼ å¤„ç† ---
        document.getElementById('photo-upload').addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length === 0) return;

            userPhotos = [];
            // è·å–æ‰€æœ‰ç…§ç‰‡ Mesh
            const photoMeshes = objects.filter(o => o.userData.isPhoto);
            let photoIndex = 0;

            Array.from(files).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.src = evt.target.result;
                    const tex = new THREE.Texture(img);
                    img.onload = () => { tex.needsUpdate = true; };
                    
                    userPhotos.push(tex);

                    // å¦‚æœè¿˜æœ‰å‰©ä½™çš„ç…§ç‰‡Meshï¼Œåˆ†é…çº¹ç†
                    if (photoIndex < photoMeshes.length) {
                         // éšæœºåˆ†é…é¢œè‰²æˆ–æ ·å¼ç»™éç…§ç‰‡ç‰©ä½“ï¼Œè¿™é‡Œåªæ›´æ–°ç…§ç‰‡
                         photoMeshes[photoIndex].material.map = tex;
                         photoMeshes[photoIndex].material.color.setHex(0xffffff); // é‡ç½®é¢œè‰²ä¸ºç™½ä»¥æ˜¾ç¤ºå›¾ç‰‡
                         photoMeshes[photoIndex].material.needsUpdate = true;
                         photoIndex++;
                    }
                };
                reader.readAsDataURL(file);
            });
            alert(`å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡ï¼Œæ­£åœ¨åº”ç”¨åˆ°ç²’å­ä¸­...`);
        });

        // --- çŠ¶æ€è½¬æ¢é€»è¾‘ (GSAP) ---
        function changeState(newState, handData = null) {
            if (currentState === newState && newState !== 'SCATTER') return; // SCATTER å…è®¸æŒç»­æ›´æ–°æ—‹è½¬
            
            // çŠ¶æ€å˜æ›´æ—¶çš„å•æ¬¡å¤„ç†
            if(currentState !== newState) {
                previousState = currentState;
                currentState = newState;
                document.getElementById('state-text').innerText = 
                    newState === 'TREE' ? "åˆæ‹¢æ€ (Tree)" : 
                    newState === 'SCATTER' ? "æ•£å¼€æ€ (Scatter)" : "ç…§ç‰‡æ”¾å¤§æ€ (Zoom)";
            }

            // 1. åˆæ‹¢æ€ (æ ‘)
            if (newState === 'TREE') {
                objects.forEach(obj => {
                    gsap.to(obj.position, {
                        x: obj.userData.posTree.x,
                        y: obj.userData.posTree.y,
                        z: obj.userData.posTree.z,
                        duration: 1.5,
                        ease: "power2.inOut"
                    });
                    gsap.to(obj.rotation, {
                        x: obj.userData.rotTree.x,
                        y: obj.userData.rotTree.y,
                        z: obj.userData.rotTree.z,
                        duration: 1.5
                    });
                    gsap.to(obj.scale, {
                        x: obj.userData.baseScale.x,
                        y: obj.userData.baseScale.y,
                        z: obj.userData.baseScale.z,
                        duration: 1
                    });
                });
                // ç›¸æœºå½’ä½
                gsap.to(camera.position, { x: 0, y: 10, z: 50, duration: 1.5 });
            }

            // 2. æ•£å¼€æ€
            else if (newState === 'SCATTER') {
                objects.forEach(obj => {
                    gsap.to(obj.position, {
                        x: obj.userData.posScatter.x,
                        y: obj.userData.posScatter.y,
                        z: obj.userData.posScatter.z,
                        duration: 2,
                        ease: "power3.out"
                    });
                    gsap.to(obj.rotation, {
                        x: obj.userData.rotScatter.x,
                        y: obj.userData.rotScatter.y,
                        duration: 2
                    });
                     gsap.to(obj.scale, {
                        x: obj.userData.baseScale.x,
                        y: obj.userData.baseScale.y,
                        z: obj.userData.baseScale.z,
                        duration: 0.5
                    });
                });

                // æ‰‹åŠ¿æ—‹è½¬ç›¸æœº
                if (handData) {
                    // x: 0~1, y: 0~1. æ˜ å°„åˆ°è§’åº¦
                    const rotX = (handData.y - 0.5) * 2; // -1 to 1
                    const rotY = (handData.x - 0.5) * 4; // -2 to 2

                    // ä½¿ç”¨ GSAP å¹³æ»‘ç›¸æœºç§»åŠ¨
                    gsap.to(camera.position, {
                        x: Math.sin(rotY) * 60,
                        y: rotX * 20 + 10,
                        z: Math.cos(rotY) * 60,
                        duration: 1
                    });
                    camera.lookAt(0, 0, 0);
                }
            }

            // 3. ç…§ç‰‡æ”¾å¤§æ€
            else if (newState === 'ZOOM') {
                // æ‰¾åˆ°ä¸€ä¸ªâ€œç›®æ ‡â€ç…§ç‰‡ã€‚ç®€å•èµ·è§ï¼Œæˆ‘ä»¬éšæœºé€‰ä¸€ä¸ªå¸¦isPhotoçš„ï¼Œæˆ–è€…åŸºäºæ‰‹åŠ¿ä½ç½®é€‰ï¼ˆæ­¤å¤„ç®€åŒ–ä¸ºéšæœºæˆ–è½®è¯¢ï¼‰
                // å¦‚æœä¹‹å‰æ²¡é€‰ä¸­ï¼Œé€‰ä¸€ä¸ª
                let targetObj;
                const photoObjs = objects.filter(o => o.userData.isPhoto);
                
                if (photoObjs.length > 0) {
                    // ç®€å•çš„æ¨¡æ‹Ÿï¼šæ¯æ¬¡è¿›å…¥Zooméšæœºé€‰ä¸€å¼ ï¼Œæˆ–è€…é€‰è·ç¦»å±å¹•ä¸­å¿ƒæœ€è¿‘çš„
                    if(selectedPhotoIndex === -1 || Math.random() > 0.5) {
                        selectedPhotoIndex = Math.floor(Math.random() * photoObjs.length);
                    }
                    targetObj = photoObjs[selectedPhotoIndex];
                }

                if (targetObj) {
                    // èƒŒæ™¯æ•£å¼€
                    objects.forEach(obj => {
                        if (obj !== targetObj) {
                            gsap.to(obj.position, {
                                x: obj.userData.posScatter.x * 1.5, // ç¨å¾®æ¨è¿œ
                                y: obj.userData.posScatter.y * 1.5,
                                z: obj.userData.posScatter.z * 1.5 - 20, // æ¨åˆ°åé¢
                                duration: 1
                            });
                        }
                    });

                    // ç›®æ ‡ç…§ç‰‡é£åˆ°é¢å‰
                    gsap.to(targetObj.position, {
                        x: camera.position.x * 0.2, // ç¨å¾®æ”¾åœ¨ç›¸æœºå‰
                        y: camera.position.y + 0,
                        z: camera.position.z - 10, // æ”¾ç½®åœ¨ç›¸æœºå‰æ–¹
                        duration: 1,
                        ease: "back.out(1.7)"
                    });
                    
                    // æ°¸è¿œæœå‘ç›¸æœº
                    targetObj.lookAt(camera.position);
                    
                    gsap.to(targetObj.scale, {
                        x: 5, y: 5, z: 5, duration: 1
                    });
                }
            }
        }

        // --- MediaPipe Hands é›†æˆ ---
        const videoElement = document.getElementById('video-input');
        const canvasElement = document.getElementById('canvas-container'); // Use this for gesture debug if needed
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('video-input').style.display = 'block';

            let gesture = 'NONE';
            let handData = null; // Store hand center for rotation

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // ç®€å•çš„æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
                // 1. è®¡ç®—æŒ‡å°–ä¸æ‰‹æŒåŸºéƒ¨(0)çš„è·ç¦»
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky
                let fingersExtended = 0;
                
                tips.forEach(idx => {
                    const dy = landmarks[idx].y - wrist.y;
                    // æ³¨æ„ï¼šYè½´å‘ä¸‹å¢åŠ ï¼Œæ‰€ä»¥æŒ‡å°–åœ¨æ‰‹è…•ä¸Šæ–¹æ„å‘³ç€ y_tip < y_wrist (å¦‚æœæ‰‹æŒæœä¸Šä¸”å‚ç›´)
                    // è¿™é‡Œç”¨è·ç¦»åˆ¤æ–­æ›´é€šç”¨
                    const dist = Math.sqrt(
                        Math.pow(landmarks[idx].x - wrist.x, 2) + 
                        Math.pow(landmarks[idx].y - wrist.y, 2)
                    );
                    if (dist > 0.25) fingersExtended++; // é˜ˆå€¼æ ¹æ®å®é™…è°ƒè¯•
                });

                // 2. æåˆåˆ¤æ–­ (Thumb tip 4 vs Index tip 8)
                const pinchDist = Math.sqrt(
                    Math.pow(landmarks[4].x - landmarks[8].x, 2) + 
                    Math.pow(landmarks[4].y - landmarks[8].y, 2)
                );

                // --- åˆ¤å®šé€»è¾‘ ---
                if (pinchDist < 0.05) {
                    gesture = 'PINCH'; // æŠ“å–
                } else if (fingersExtended <= 1) {
                    gesture = 'FIST'; // æ¡æ‹³
                } else if (fingersExtended >= 4) {
                    gesture = 'OPEN'; // å¼ å¼€
                } else {
                    gesture = 'MOVING'; // é»˜è®¤è§†ä¸ºç§»åŠ¨/æ—‹è½¬
                }

                // è®¡ç®—æ‰‹æŒä¸­å¿ƒç”¨äºæ—‹è½¬æ§åˆ¶
                handData = {
                    x: landmarks[9].x, // Middle finger MCP
                    y: landmarks[9].y
                };
            }

            // æ›´æ–° UI
            const gestureText = {
                'NONE': 'æœªæ£€æµ‹åˆ°',
                'FIST': 'âœŠ æ¡æ‹³ (èšåˆ)',
                'OPEN': 'ğŸ– å¼ å¼€ (æ•£å¼€)',
                'PINCH': 'ğŸ‘Œ æåˆ (æŸ¥çœ‹)',
                'MOVING': 'ğŸ‘‹ ç§»åŠ¨ (æ—‹è½¬)'
            };
            document.getElementById('gesture-text').innerText = gestureText[gesture] || '...';

            // è§¦å‘çŠ¶æ€æœº
            if (gesture === 'FIST') {
                changeState('TREE');
            } else if (gesture === 'OPEN') {
                changeState('SCATTER', handData); // ä¼ å…¥ handData ç”¨äºåˆæ¬¡å®šä½æˆ–ä¿æŒ
            } else if (gesture === 'MOVING' && currentState === 'SCATTER') {
                changeState('SCATTER', handData); // ä»…åœ¨æ•£å¼€æ€ä¸‹å…è®¸æ—‹è½¬
            } else if (gesture === 'PINCH') {
                changeState('ZOOM');
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // --- æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // è®©æ ‘ç¨å¾®è‡ªè½¬ï¼Œå¢åŠ åŠ¨æ„Ÿ
            if (currentState === 'TREE') {
                scene.rotation.y += 0.002;
            } else {
                // æ•£å¼€æ—¶åœºæ™¯ä¸è‡ªè½¬ï¼Œç”±æ‰‹åŠ¿æ§åˆ¶ç›¸æœº
                // æ¢å¤åœºæ™¯æ—‹è½¬
                gsap.to(scene.rotation, { y: 0, duration: 1 });
            }

            // ç²’å­è‡ªèº«å¾®åŠ¨ (æ¼‚æµ®æ„Ÿ)
            const time = Date.now() * 0.001;
            objects.forEach((obj, i) => {
                if (currentState !== 'TREE') {
                    obj.rotation.x += 0.01;
                    obj.rotation.y += 0.01;
                    // ä¸Šä¸‹æµ®åŠ¨
                    obj.position.y += Math.sin(time + i) * 0.02;
                }
            });

            composer.render();
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
