<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Dr. Strange (Global/Debug)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: monospace; }
        
        /* 布局容器 */
        #container { position: relative; width: 100%; height: 100%; }

        /* 层级 1: 摄像头画面 + 骨架绘制 (最底层) */
        #output-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            transform: scaleX(-1); /* 镜像翻转 */
            z-index: 1;
            object-fit: cover;
        }

        /* 层级 2: Three.js 魔法特效 (叠加层) */
        #three-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* 让鼠标事件穿透 */
            z-index: 2;
        }

        /* 层级 3: 调试日志控制台 */
        #console-log {
            position: absolute; top: 10px; left: 10px; width: 300px; max-height: 50%;
            background: rgba(0, 0, 0, 0.8); color: #00ff88;
            padding: 10px; border-radius: 8px; border: 1px solid #004422;
            overflow-y: auto; font-size: 11px; z-index: 100;
            pointer-events: none;
        }
        .log-error { color: #ff3333; font-weight: bold; border-top: 1px solid #550000; margin-top:5px; padding-top:5px;}
        .log-warn { color: #ffaa00; }
        .log-info { color: #00ff88; }

        /* 隐藏原始视频元素 (我们画在 canvas 上) */
        #input-video { display: none; }

        /* HUD */
        #hud {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            z-index: 50; pointer-events: none;
        }
        .status-text {
            display: inline-block; background: rgba(0,0,0,0.6); color: #f5a623;
            padding: 10px 20px; border-radius: 30px; font-size: 16px; font-weight: bold;
            border: 1px solid rgba(245, 166, 35, 0.3);
        }
    </style>
</head>
<body>

    <!-- 日志窗口 -->
    <div id="console-log">
        <div>[SYSTEM] Booting up...</div>
    </div>

    <!-- 原始视频源 (隐藏) -->
    <video id="input-video" playsinline webkit-playsinline></video>

    <!-- 视觉层 -->
    <div id="container">
        <canvas id="output-canvas"></canvas> <!-- 摄像头+骨架 -->
        <canvas id="three-canvas"></canvas>  <!-- 魔法传送门 -->
    </div>

    <div id="hud">
        <div class="status-text" id="status-msg">INITIALIZING...</div>
    </div>

    <!-- 
        全球标准源 (Global CDN)
        如果不挂梯子，在这里可能会加载失败
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe 核心 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 0. 日志系统 ---
        const logBox = document.getElementById('console-log');
        function log(msg, type = 'info') {
            const div = document.createElement('div');
            const time = new Date().toISOString().split('T')[1].split('.')[0];
            div.innerHTML = `<span style="opacity:0.5">[${time}]</span> ${msg}`;
            if (type === 'error') div.className = 'log-error';
            else if (type === 'warn') div.className = 'log-warn';
            logBox.appendChild(div);
            logBox.scrollTop = logBox.scrollHeight;
            console.log(msg);
        }

        window.onerror = function(msg, url, line) {
            log(`CRITICAL ERROR: ${msg} (Line ${line})`, 'error');
            return false;
        };

        // --- 1. Three.js 魔法特效 ---
        log("Step 1: Initializing Graphics Engine...");
        
        const threeCanvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();
        // 稍微透明一点的背景，让摄像头画面能透出来
        // 但我们用 renderer 的 alpha:true 已经处理了
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

        // 纹理生成
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
        const ctx = cvs.getContext('2d');
        const grd = ctx.createRadialGradient(32,32,0, 32,32,32);
        grd.addColorStop(0,'white'); grd.addColorStop(0.3,'#ffaa00'); grd.addColorStop(1,'transparent');
        ctx.fillStyle = grd; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(cvs);

        // 粒子系统
        const count = 3000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count*3);
        const attr = new Float32Array(count*3); // x:speed, y:angle, z:jitter
        
        for(let i=0; i<count; i++) {
            pos[i*3]=999; // 初始隐藏
            attr[i*3] = 2 + Math.random()*4; 
            attr[i*3+1] = Math.random() * Math.PI * 2;
            attr[i*3+2] = (Math.random()-0.5)*1.5;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const mat = new THREE.PointsMaterial({
            size:0.4, map:tex, transparent:true, 
            blending:THREE.AdditiveBlending, depthWrite:false, color:0xffaa00
        });
        const ring = new THREE.Points(geo, mat);
        scene.add(ring);

        // 虚空 (黑色球体，遮挡后面的摄像头画面，制造空间感)
        const voidMesh = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1, 2),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        scene.add(voidMesh);

        // 状态
        let State = { r: 0, tr: 0 }; // r=currentRadius, tr=targetRadius

        function animateThree() {
            requestAnimationFrame(animateThree);
            
            // 缓动
            State.r += (State.tr - State.r) * 0.1;
            
            // 虚空球体更新
            voidMesh.scale.setScalar(State.r * 0.9);
            // 随着半径变大，虚空完全不透明(黑色)，遮住后面的摄像头
            // 但为了好看，我们其实不需要完全遮住，或者设为半透明
            voidMesh.material.transparent = true;
            voidMesh.material.opacity = Math.min(0.9, State.r / 4); 

            // 粒子更新
            ring.rotation.z -= 0.05;
            const p = ring.geometry.attributes.position.array;
            
            for(let i=0; i<count; i++) {
                attr[i*3+1] += attr[i*3]*0.01; // angle += speed
                const r = State.r + attr[i*3+2]; // radius + jitter
                
                if(State.r > 0.1) {
                    p[i*3] = Math.cos(attr[i*3+1]) * r + (Math.random()-0.5)*0.2;
                    p[i*3+1] = Math.sin(attr[i*3+1]) * r + (Math.random()-0.5)*0.2;
                    p[i*3+2] = (Math.random()-0.5);
                } else {
                    p[i*3] = 999;
                }
            }
            ring.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animateThree();
        log("Graphics Engine Ready.");


        // --- 2. MediaPipe Hands + Drawing ---
        log("Step 2: Initializing AI Core...");
        
        const videoElement = document.getElementById('input-video');
        const outputCanvas = document.getElementById('output-canvas');
        const canvasCtx = outputCanvas.getContext('2d');
        const statusMsg = document.getElementById('status-msg');

        // 检测库是否加载
        if (typeof Hands === 'undefined') {
            log("ERROR: MediaPipe Hands lib not loaded. Check Network/VPN.", 'error');
            statusMsg.innerText = "Library Load Failed";
            throw new Error("Library missing");
        }

        const hands = new Hands({locateFile: (file) => {
            log(`Downloading: ${file} ...`);
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2, // 关键：双手
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        let isModelLoaded = false;

        hands.onResults(onResults);

        function onResults(results) {
            if (!isModelLoaded) {
                isModelLoaded = true;
                log("AI Model Loaded Successfully!", 'info');
                statusMsg.innerText = "SYSTEM READY - SHOW HANDS";
                statusMsg.style.color = "#fff";
            }

            // 1. 绘制摄像头背景和骨架
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // 绘制视频帧 (作为背景)
            canvasCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
            
            // 2. 处理手势逻辑
            const handCount = results.multiHandLandmarks.length;
            
            if (handCount > 0) {
                // 绘制骨架
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});
                }

                // 逻辑控制
                if (handCount === 2) {
                    const h1 = results.multiHandLandmarks[0][9]; // 中指根部
                    const h2 = results.multiHandLandmarks[1][9];
                    
                    // 计算距离 (MediaPipe 坐标是 0.0 ~ 1.0)
                    const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    
                    // 映射：距离 0.1 -> 半径0，距离 0.6 -> 半径7
                    const target = Math.max(0, (dist - 0.1) * 14);
                    State.tr = Math.min(target, 7);
                    
                    statusMsg.innerText = `DUAL HAND LINK: ${(dist*100).toFixed(0)}%`;
                    statusMsg.style.color = "#00ff88";
                } else {
                    State.tr = 0;
                    statusMsg.innerText = "REQUIRE TWO HANDS";
                    statusMsg.style.color = "#f5a623";
                }
            } else {
                // 无手
                State.tr = 0;
                statusMsg.innerText = "NO SIGNAL";
                statusMsg.style.color = "#aaa";
            }
            
            canvasCtx.restore();
        }

        // --- 3. Camera Setup ---
        log("Step 3: Requesting Camera Access...");
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640, height: 480, facingMode: 'user'
        });

        cameraUtils.start()
            .then(() => {
                log("Camera Started. Waiting for AI...", 'info');
                // 调整画布大小匹配
                outputCanvas.width = 640;
                outputCanvas.height = 480;
            })
            .catch(err => {
                log(`CAMERA ERROR: ${err.message}`, 'error');
                statusMsg.innerText = "CAMERA DENIED";
                statusMsg.style.color = "red";
            });

        // 窗口适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
